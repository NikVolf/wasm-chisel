//! Chisel driver implementation.
//! ChiselDriver is a state machine-like structure implementing the core logic for chisel
//! execution.
//! It consumes a ChiselConfig generated by its caller and executes the specified rulesets.
//! If it enters an error state, it is up to the caller to handle it. If called again, the ruleset
//! in which the error occurred is dropped.
//! Upon completed execution, the driver returns a ChiselResult structure.

use std::error::Error;
use std::fmt::{self, Display};
use std::fs::{canonicalize, read};
use std::path::PathBuf;

use crate::config::ChiselConfig;
use crate::result::{ChiselResult, ModuleResult, RulesetResult};

use libchisel::{
    checkfloat::CheckFloat,
    checkstartfunc::CheckStartFunc,
    //deployer::Deployer,
    dropsection::DropSection,
    //fromwat
    remapimports::RemapImports,
    remapstart::RemapStart,
    repack::Repack,
    snip::Snip,
    trimexports::TrimExports,
    trimstartfunc::TrimStartFunc,
    verifyexports::VerifyExports,
    verifyimports::VerifyImports,
    Module,
    ModulePreset,
    ModuleTranslator,
    ModuleValidator,
};

/// State machine implementing the main chisel execution loop. Consumes ChiselConfig and returns
/// ChiselResult, with an intermediate state returned to allow error handling.
pub struct ChiselDriver {
    config: ChiselConfig,
    state: DriverState,
}

/// The state of the chisel driver.
pub enum DriverState {
    Ready,
    Error(DriverError, ChiselResult),
    Done(ChiselResult),
}

pub enum DriverError {
    /// A module or ruleset is missing a required field. Left-hand is the config object name,
    /// right-hand is the missing field.
    MissingRequiredField(String, String),
    /// The module name was not successfully resolved to an existing chisel module. Left-hand is
    /// the config object name, right-hand is the invalid module name.
    ModuleNotFound(String, String),
    /// A configuration value is of incorrect type or invalid value. Left-hand is the config object
    /// name, right-hand is the name of the invalid field.
    InvalidField(String, String),
    /// A canonicalized path was generated unsuccessfully. Left-hand is the config object name,
    /// right-hand is the invalid path.
    PathResolution(String, String),
    /// An internal error occurred. Field 0 is the config object, during the execution of which the error occurred.
    /// Field 1 is an additional informational message. Field 2 is the error generated.
    Internal(String, String, Box<dyn Error>),
}

impl ChiselDriver {
    pub fn new(config: ChiselConfig) -> Self {
        ChiselDriver {
            config,
            state: DriverState::Ready,
        }
    }

    pub fn take_result(self) -> ChiselResult {
        match self.state {
            DriverState::Ready => {
                panic!("take_result should never be called on a driver in 'ready' state")
            }
            DriverState::Error(_, result) => result,
            DriverState::Done(result) => result,
        }
    }

    pub fn fire(&mut self) -> &DriverState {
        let mut results = match &mut self.state {
            DriverState::Ready => ChiselResult::new(),
            DriverState::Error(_, previous_result) => previous_result.clone(),
            DriverState::Done(_) => panic!("fire() called on a completed driver"),
        };

        // Consume the rulesets in the configuration and execute each one.
        while let Some((name, mut ruleset)) = self.config.rulesets_mut().pop_front() {
            let mut ruleset_result = RulesetResult::new(name.clone());

            // Load binary.
            chisel_debug!(1, "Running ruleset {}", name);
            chisel_debug!(1, "Looking for binary path...");
            let binary_path = if let Some(binary_path) = ruleset.options().get(&"file".to_string())
            {
                chisel_debug!(1, "Found binary path: {}", &binary_path);
                chisel_debug!(1, "Attempting to resolve path...");

                match canonicalize(binary_path) {
                    Ok(path_resolved) => {
                        chisel_debug!(1, "Successfully resolved binary path");
                        path_resolved
                    }
                    Err(_) => {
                        chisel_debug!(1, "Failed to resolve binary path");
                        self.state = DriverState::Error(
                            DriverError::PathResolution(name.clone(), binary_path.clone()),
                            results,
                        );
                        return &self.state;
                    }
                }
            } else {
                self.state = DriverState::Error(
                    DriverError::MissingRequiredField(name.clone(), "file".to_string()),
                    results,
                );
                return &self.state;
            };

            // Look for output path and set.
            let output_path =
                if let Some(output_path) = ruleset.options().get(&"output".to_string()) {
                    chisel_debug!(1, "Found output path: {}", &output_path);
                    PathBuf::from(output_path)
                } else {
                    chisel_debug!(1, "No output path found.");
                    binary_path.clone()
                };
            ruleset_result.set_output_path(output_path);

            // Load the wasm binary into a buffer before deserialization.
            chisel_debug!(1, "Deserializing module from file");
            let wasm_raw = match read(binary_path) {
                Ok(ret) => ret,
                Err(e) => {
                    chisel_debug!(1, "Failed to load Wasm binary");
                    self.state = DriverState::Error(
                        DriverError::Internal(
                            name.clone(),
                            "Failed to load file".to_string(),
                            e.into(),
                        ),
                        results,
                    );
                    return &self.state;
                }
            };

            // Deserialize the Wasm binary and parse its names section.
            let mut wasm = match Module::from_bytes(wasm_raw) {
                Ok(wasm) => {
                    chisel_debug!(1, "Successfully deserialized Wasm module");
                    // TODO: Make this error recoverable
                    wasm.parse_names().expect("names parsing failed")
                }
                Err(e) => {
                    chisel_debug!(1, "Failed to deserialize Wasm module");
                    self.state = DriverState::Error(
                        DriverError::Internal(
                            name.clone(),
                            "Deserialization failure".to_string(),
                            e.into(),
                        ),
                        results,
                    );
                    return &self.state;
                }
            };

            // Consume modules in ruleset and execute.
            while let Some((name, module)) = ruleset.modules_mut().pop_front() {
                chisel_debug!(1, "Executing module {}", &name);

                // TODO: homogeneous module handling
                let module_result = match name.as_str() {
                    "checkfloat" => {
                        let checkfloat = CheckFloat::new();
                        let module_result = checkfloat.validate(&wasm);
                        ModuleResult::Validator(name.clone(), module_result)
                    }
                    "checkstartfunc" => {
                        if let Some(require_start) = module.options().get("require_start") {
                            let require_start = match require_start.as_str() {
                                "true" => true,
                                "false" => false,
                                _ => {
                                    self.state = DriverState::Error(
                                        DriverError::InvalidField(
                                            name.clone(),
                                            "require_start".to_string(),
                                        ),
                                        results,
                                    );
                                    return &self.state;
                                }
                            };
                            let checkstartfunc = CheckStartFunc::new(require_start);
                            let module_result = checkstartfunc.validate(&wasm);
                            ModuleResult::Validator(name.clone(), module_result)
                        } else {
                            chisel_debug!(1, "checkstartfunc missing field 'require_start'");
                            self.state = DriverState::Error(
                                DriverError::MissingRequiredField(
                                    name.clone(),
                                    "require_start".to_string(),
                                ),
                                results,
                            );
                            return &self.state;
                        }
                    }
                    "deployer" => unimplemented!("Creator modules are not supported yet."),
                    "dropsection" => {
                        match (module.options().get("mode"), module.options().get("key")) {
                            (Some(mode), Some(key)) => {
                                let dropsections = match mode.as_str() {
                                    "names" => {
                                        // Ignore key here.
                                        vec![DropSection::NamesSection]
                                    }
                                    // TODO: Split into a batch
                                    "custom_by_name" => key
                                        .split(',')
                                        .filter(|val| *val != "" && *val != " ")
                                        .map(|val| {
                                            chisel_debug!(
                                                1,
                                                "Loading dropsection for name: '{}'",
                                                val
                                            );
                                            DropSection::CustomSectionByName(val.to_string())
                                        })
                                        .collect(),
                                    m @ "custom_by_index" | m @ "unknown_by_index" => {
                                        chisel_debug!(1, "Running dropsection in mode {}", m);
                                        // TODO: Split into a helper
                                        // First generate a set of section indices to drop from the
                                        // comma-separated list we produced during config parsing.
                                        let (indices, mut errs): (Vec<Result<u64, Box<dyn Error>>>, Vec<Result<u64, Box<dyn Error>>>) = key.split(',')
                                            .filter(|val| *val != "" && *val != " ")
                                            .map(|val|
                                                match str::parse::<u64>(val) {
                                                    Ok(index) => {
                                                        chisel_debug!(1, "Loading dropsection for index: {}", index);
                                                        Ok(index)
                                                    },
                                                    Err(e) => {
                                                        chisel_debug!(1, "dropsection failed to parse integer value: {}", e);
                                                        Err(e.into())
                                                    },
                                                },
                                            )
                                            .partition(|i| i.is_ok());
                                        // If the right-hand partition contains any errors,
                                        // propagate the last one.
                                        if let Some(e) = errs.pop() {
                                            // For now, just use the last error as we only have
                                            // one error case.
                                            self.state = DriverState::Error(
                                                DriverError::Internal(
                                                    name.clone(),
                                                    "Expected integer value".to_string(),
                                                    e.unwrap_err(),
                                                ),
                                                results,
                                            );
                                            return &self.state;
                                        }
                                        // Collect the indices into a vec of initialized
                                        // DropSection modules.
                                        indices
                                            .into_iter()
                                            .map(|idx| match m {
                                                "custom_by_index" => {
                                                    DropSection::CustomSectionByIndex(
                                                        idx.expect("Already handled errors")
                                                            as usize,
                                                    )
                                                }
                                                "unknown_by_index" => {
                                                    DropSection::UnknownSectionByIndex(
                                                        idx.expect("Already handled errors")
                                                            as usize,
                                                    )
                                                }
                                                _ => panic!(
                                                    "Parent match ensures this cannot be reached"
                                                ),
                                            })
                                            .collect()
                                    }
                                    _ => {
                                        chisel_debug!(1, "dropsection given invalid mode");
                                        self.state = DriverState::Error(
                                            DriverError::InvalidField(
                                                name.clone(),
                                                "mode".to_string(),
                                            ),
                                            results,
                                        );
                                        return &self.state;
                                    }
                                };
                                let module_result = dropsections
                                    .iter()
                                    .map(|i| i.translate_inplace(&mut wasm))
                                    .fold(Ok(false), |acc, result| match result {
                                        Ok(true) => result,
                                        Ok(false) => acc,
                                        Err(e) => Err(e),
                                    });
                                ModuleResult::Translator(name.clone(), module_result)
                            }
                            (Some(mode), None) => {
                                if mode.as_str() == "names" {
                                    let dropsection = DropSection::NamesSection;
                                    let module_result = dropsection.translate_inplace(&mut wasm);
                                    ModuleResult::Translator(name.clone(), module_result)
                                } else {
                                    chisel_debug!(1, "dropsection missing field 'key' and not in names section mode");
                                    self.state = DriverState::Error(
                                        DriverError::MissingRequiredField(
                                            name.clone(),
                                            "key".to_string(),
                                        ),
                                        results,
                                    );
                                    return &self.state;
                                }
                            }
                            (None, _) => {
                                chisel_debug!(1, "dropsection missing field 'mode'");
                                self.state = DriverState::Error(
                                    DriverError::MissingRequiredField(
                                        name.clone(),
                                        "mode".to_string(),
                                    ),
                                    results,
                                );
                                return &self.state;
                            }
                        }
                    }
                    "fromwat" => unimplemented!("Creator modules are not supported yet."),
                    "remapimports" => {
                        if let Some(preset) = module.options().get("preset") {
                            let remapimports = RemapImports::with_preset(preset.as_str());
                            if let Ok(remapimports) = remapimports {
                                // TODO: try other translate method as well as well
                                let module_result = remapimports.translate_inplace(&mut wasm);
                                ModuleResult::Translator(name.clone(), module_result)
                            } else {
                                chisel_debug!(1, "remapimports given invalid preset");
                                self.state = DriverState::Error(
                                    DriverError::InvalidField(name.clone(), "preset".to_string()),
                                    results,
                                );
                                return &self.state;
                            }
                        } else {
                            chisel_debug!(1, "remapimports missing field 'preset'");
                            self.state = DriverState::Error(
                                DriverError::MissingRequiredField(
                                    name.clone(),
                                    "preset".to_string(),
                                ),
                                results,
                            );
                            return &self.state;
                        }
                    }
                    "remapstart" => {
                        // NOTE: preset "ewasm" maps to the default and only mode. Fixing
                        // later.
                        let remapstart = RemapStart::with_preset("ewasm").expect("Should not fail");
                        let module_result = remapstart.translate_inplace(&mut wasm);
                        ModuleResult::Translator(name.clone(), module_result)
                    }
                    "repack" => {
                        let repack = Repack::new();
                        let module_result = repack.translate_inplace(&mut wasm);
                        ModuleResult::Translator(name.clone(), module_result)
                    }
                    "snip" => {
                        let snip = Snip::new();
                        let module_result = snip.translate_inplace(&mut wasm);
                        ModuleResult::Translator(name.clone(), module_result)
                    }
                    "trimexports" => {
                        if let Some(preset) = module.options().get("preset") {
                            let trimexports = TrimExports::with_preset(preset.as_str());
                            if let Ok(trimexports) = trimexports {
                                // TODO: try other translate method as well as well
                                let module_result = trimexports.translate_inplace(&mut wasm);
                                ModuleResult::Translator(name.clone(), module_result)
                            } else {
                                chisel_debug!(1, "trimexports given invalid preset");
                                self.state = DriverState::Error(
                                    DriverError::InvalidField(name.clone(), "preset".to_string()),
                                    results,
                                );
                                return &self.state;
                            }
                        } else {
                            chisel_debug!(1, "remapimports missing field 'preset'");
                            self.state = DriverState::Error(
                                DriverError::MissingRequiredField(
                                    name.clone(),
                                    "preset".to_string(),
                                ),
                                results,
                            );
                            return &self.state;
                        }
                    }
                    "trimstartfunc" => {
                        // NOTE: preset "ewasm" maps to the default and only mode. Fixing
                        // later.
                        let trimstartfunc =
                            TrimStartFunc::with_preset("ewasm").expect("Should not fail");
                        let module_result = trimstartfunc.translate_inplace(&mut wasm);
                        ModuleResult::Translator(name.clone(), module_result)
                    }
                    "verifyexports" => {
                        if let Some(preset) = module.options().get("preset") {
                            let verifyexports = VerifyExports::with_preset(preset.as_str());
                            if let Ok(verifyexports) = verifyexports {
                                // TODO: try other translate method as well as well
                                let module_result = verifyexports.validate(&wasm);
                                ModuleResult::Validator(name.clone(), module_result)
                            } else {
                                chisel_debug!(1, "verifyexports given invalid preset");
                                self.state = DriverState::Error(
                                    DriverError::InvalidField(name.clone(), "preset".to_string()),
                                    results,
                                );
                                return &self.state;
                            }
                        } else {
                            chisel_debug!(1, "verifyexports missing field 'preset'");
                            self.state = DriverState::Error(
                                DriverError::MissingRequiredField(
                                    name.clone(),
                                    "preset".to_string(),
                                ),
                                results,
                            );
                            return &self.state;
                        }
                    }
                    "verifyimports" => {
                        if let Some(preset) = module.options().get("preset") {
                            let verifyimports = VerifyImports::with_preset(preset.as_str());
                            if let Ok(verifyimports) = verifyimports {
                                // TODO: try other translate method as well as well
                                let module_result = verifyimports.validate(&wasm);
                                ModuleResult::Validator(name.clone(), module_result)
                            } else {
                                chisel_debug!(1, "verifyimports given invalid preset");
                                self.state = DriverState::Error(
                                    DriverError::InvalidField(name.clone(), "preset".to_string()),
                                    results,
                                );
                                return &self.state;
                            }
                        } else {
                            chisel_debug!(1, "verifyimports missing field 'preset'");
                            self.state = DriverState::Error(
                                DriverError::MissingRequiredField(
                                    name.clone(),
                                    "preset".to_string(),
                                ),
                                results,
                            );
                            return &self.state;
                        }
                    }
                    other => {
                        self.state = DriverState::Error(
                            DriverError::ModuleNotFound(name.clone(), other.to_string()),
                            results,
                        );
                        return &self.state;
                    }
                };

                // If the module was a translator or creator, we set the output in the result.
                match module_result {
                    ModuleResult::Creator(_, ref result)
                    | ModuleResult::Translator(_, ref result) => {
                        if let Ok(true) = result {
                            chisel_debug!(1, "Module mutated or created.");
                            ruleset_result.set_output_module(wasm.clone()); //TODO: Refactor to only set this at the end and save some expensive copies
                        }
                    }
                    ModuleResult::Validator(_, _) => (),
                }
                ruleset_result.results_mut().push(module_result);
            }
            results.rulesets_mut().push(ruleset_result);
        }
        self.state = DriverState::Done(results);
        &self.state
    }
}

// Error.description() is deprecated for displaying errors now.
impl Display for DriverError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            DriverError::MissingRequiredField(object, field) => {
                write!(f, "in '{}': missing required field '{}'", object, field)
            }
            DriverError::ModuleNotFound(object, module) => {
                write!(f, "in '{}': module '{}' not found", object, module)
            }
            DriverError::InvalidField(object, field) => {
                write!(f, "in '{}': invalid field '{}'", object, field)
            }
            DriverError::PathResolution(object, path) => {
                write!(f, "in '{}': failed to resolve path '{}'", object, path)
            }
            DriverError::Internal(object, info, err) => {
                write!(f, "in '{}': {}; {}", object, info, err)
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use std::panic::catch_unwind;

    use super::*;
    use crate::config::{ChiselConfig, FromArgs};

    #[test]
    fn take_result_ready() {
        let result = catch_unwind(|| {
            let config = ChiselConfig::from_args("test", "test.foo=bar").expect("Cannot fail");
            let driver = ChiselDriver::new(config);
            driver.take_result()
        });
        assert!(result.is_err());
    }
}
